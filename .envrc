#########################################################################
#
#                 -- Generated with omgcmd --
#      (do not edit unless you know what you're doing)
#
#########################################################################

# Copyright (C) 2022 One More Game - All Rights Reserved
# Unauthorized copying of this file, via any medium is strictly prohibited
# Proprietary and confidential

# -*- mode: sh -*-
# Load environment variables from `nix-shell` and export it out.
#
# Usage: use_nix [-s <nix-expression>] [-w <path>] [-w <path>] ...
#   -s nix-expression: The nix expression to use for building the shell environment.
#   -w path: watch a file for changes. It can be specified multiple times. The
#      shell specified with -s is automatically watched.
#
#   If no nix-expression were given with -s, it will attempt to find and load
#   the shell using the following files in order: shell.nix and default.nix.
#
# Example:
#   -  use_nix
#   -  use_nix -s shell.nix -w .nixpkgs-version.json
#
# The dependencies pulled by nix-shell are added to Nix's garbage collector
# roots, such that the environment remains persistent.
#
# Nix-shell is invoked only once per environment, and the output is cached for
# better performance. If any of the watched files change, then the environment
# is rebuilt.
#
# To remove old environments, and allow the GC to collect their dependencies:
# rm -f .direnv
#
set -euo pipefail

use_nix() {
  if ! validate_version; then
    echo "This .envrc requires direnv version 2.18.2 or above."
    exit 1
  fi

  # define all local variables
  local shell
  local files_to_watch=()
  local run_mode

  local opt OPTARG OPTIND # define vars used by getopts locally
  while getopts ":n:s:w:m:" opt; do
    case "${opt}" in
    s)
      shell="${OPTARG}"
      files_to_watch=("${files_to_watch[@]}" "${shell}")
      ;;
    w)
      files_to_watch=("${files_to_watch[@]}" "${OPTARG}")
      ;;
    m)
      run_mode=${OPTARG}
      ;;
    :)
      fail "Invalid option: $OPTARG requires an argument"
      ;;
    \?)
      fail "Invalid option: $OPTARG"
      ;;
    esac
  done
  shift $((OPTIND - 1))

  if [[ -z "${shell}" ]]; then
    if [[ -f shell.nix ]]; then
      shell=shell.nix
      files_to_watch=("${files_to_watch[@]}" shell.nix)
    elif [[ -f default.nix ]]; then
      shell=default.nix
      files_to_watch=("${files_to_watch[@]}" default.nix)
    else
      fail "ERR: no shell was given"
    fi
  fi

  local f
  for f in "${files_to_watch[@]}"; do
    if ! [[ -f "${f}" ]]; then
      fail "cannot watch file ${f} because it does not exist"
    fi
  done

  # compute the hash of all the files that makes up the development environment
  local env_hash="$(hash_contents "${files_to_watch[@]}")"

  # define the paths
  local dir="$(direnv_layout_dir)"
  local wd="${dir}/wd-${env_hash}"
  local drv="${wd}/env.drv"
  local dump="${wd}/dump.env"

  # Generate the environment if we do not have one generated already.
  if [[ ! -f "${drv}" ]]; then
    mkdir -p "${wd}"

    log_status "use nix: deriving new environment"
    IN_NIX_SHELL=1 nix-instantiate --add-root "${drv}" --indirect "${shell}" >/dev/null
    nix-store -r $(nix-store --query --references "${drv}") --add-root "${wd}/dep" --indirect >/dev/null
    if [[ "${?}" -ne 0 ]] || [[ ! -f "${drv}" ]]; then
      rm -rf "${wd}"
      fail "use nix: was not able to derive the new environment. Please run 'direnv reload' to try again."
    fi

    log_status "use nix: updating cache"
    nix-shell --pure "${drv}" --show-trace --run "$(join_args "$direnv" dump bash)" >"${dump}"
    if [[ "${?}" -ne 0 ]] || [[ ! -f "${dump}" ]] || ! grep -q IN_NIX_SHELL "${dump}"; then
      rm -rf "${wd}"
      fail "use nix: was not able to update the cache of the environment. Please run 'direnv reload' to try again."
    fi
  fi

  local path_backup="${PATH}"
  eval "$(cat "${dump}")"
  export PATH="${PATH}:${path_backup}"

  # cleanup the environment of variables that are not requried, or are causing issues.
  unset shellHook # when shellHook is present, then any nix-shell'd script will execute it!

  # watch all the files we were asked to watch for the environment
  for f in "${files_to_watch[@]}"; do
    watch_file "${f}"
  done
}

fail() {
  log_error "${@}"
  exit 1
}

hash_contents() {
  if has md5sum; then
    cat "${@}" | md5sum | cut -c -32
  elif has md5; then
    cat "${@}" | md5 -q
  fi
}

hash_file() {
  if has md5sum; then
    md5sum "${@}" | cut -c -32
  elif has md5; then
    md5 -q "${@}"
  fi
}

validate_version() {
  local version="$("${direnv}" version)"
  local major="$(echo "${version}" | cut -d. -f1)"
  local minor="$(echo "${version}" | cut -d. -f2)"
  local patch="$(echo "${version}" | cut -d. -f3)"

  if [[ "${major}" -gt 2 ]]; then return 0; fi
  if [[ "${major}" -eq 2 ]] && [[ "${minor}" -gt 18 ]]; then return 0; fi
  if [[ "${major}" -eq 2 ]] && [[ "${minor}" -eq 18 ]] && [[ "${patch}" -ge 2 ]]; then return 0; fi
  return 1
}

get_runmode() {
  lsb_release=$(lsb_release -ds 2> /dev/null)
  lsb_missing=$(echo $?)

  if [[ -n ${RUN_MODE+x} ]]; then
    echo "$RUN_MODE"
  elif [[ $lsb_missing != 0 ]]; then
    # NixOS - old, global, setup
    echo "global"
  elif [[ ${BUILD_SERVER:-0} == 1 ]] && [[ "$lsb_release" == *"Ubuntu "* ]]; then
    echo "per_env"
  else
    echo "global"
  fi
}

# -*- mode: sh -*-
PATH_add bin
PATH_add out

readonly RUN_MODE=$(get_runmode)
echo "RUN_MODE = $RUN_MODE"

# Required to be set when using the `dotnet` command in a NixOS dev shell.
# If not set, a first time experience will attempt to run which needs to
# write files to the immutable installation directory.
export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=true
export DOTNET_CLI_TELEMETRY_OPTOUT=1

# Set default environment for ASPNETCORE applications to development in
# development shell.
export ASPNETCORE_ENVIRONMENT=development

export WORKSPACE="${WORKSPACE:=$PWD}"

# Bootstrap Nix Shell
use_nix -s shell.nix -w .nixpkgs-version.json -m $RUN_MODE

# Set all Locale to en_US.UTF-8
export LANG="en_US.UTF-8"
export LANGUAGE="en_US.UTF-8"

